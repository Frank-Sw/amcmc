devtools::use_testthat()
devtools::create_description()
devtools::use_testthat()
devtools::use_mit_license()
devtools::use_build_ignore()
devtools::use_package("Rcpp")
devtools::use_rcpp()
library(amcmc)
?amccm
?amcmc
library(amcmc)
devtools::use_build_ignore("readme.rmd")
devtools::use_build_ignore("readme.md")
library(amcmc)
library(amcmc)
library(amcmc)
?amcmc
set.seed(1231)
n <- 1e3
pars <- c(mean = 2.6, sd = 3)
# Generating data and writing the log likelihood function
D <- rnorm(n, pars[1], pars[2])
fun <- function(x) {
x <- log(dnorm(D, x[1], x[2]))
sum(x)
}
# Calling MCMC, but first, loading the coda R package for
# diagnostics
library(coda)
ans <- MCMC(fun, c(mu=1, sigma=1), nbatch = 2e3, scale = .1, ub = 10, lb = 0)
# Ploting the output
oldpar <- par(no.readonly = TRUE)
par(mfrow = c(1,2))
boxplot(as.matrix(ans),
main = expression("Posterior distribution of"~mu~and~sigma),
names =  expression(mu, sigma), horizontal = TRUE,
col  = blues9[c(4,9)],
sub = bquote(mu == .(pars[1])~", and"~sigma == .(pars[2]))
)
abline(v = pars, col  = blues9[c(4,9)], lwd = 2, lty = 2)
plot(apply(as.matrix(ans), 1, fun), type = "l",
main = "LogLikelihood",
ylab = expression(L("{"~mu,sigma~"}"~"|"~D))
)
par(oldpar)
library(mvtnorm)
library(coda)
# Parameters and data simulation
S <- cbind(c(.8, .2), c(.2, 1))
M <- c(0, 1)
set.seed(123)
D <- rmvnorm(5e3, mean = M, sigma = S)
# Function to pass to MCMC
fun <- function(pars) {
# Putting the parameters in a sensible way
m <- pars[1:2]
s <- cbind( c(pars[3], pars[4]), c(pars[4], pars[5]) )
# Computing the unnormalized log likelihood
sum(log(dmvnorm(D, m, s)))
}
# Calling MCMC
ans <- MCMC(
fun,
initial = c(mu0=5, mu1=5, s0=5, s01=0, s2=5),
lb      = c(-10, -10, .01, -5, .01),
ub      = 5,
nbatch  = 1e5,
thin    = 20,
scale   = .01,
burnin  = 5e3,
useCpp  = TRUE
)
# Checking out the outcomes
plot(ans)
fun <- function(pars, D) {
# Putting the parameters in a sensible way
m <- pars[1:2]
s <- cbind( c(pars[3], pars[4]), c(pars[4], pars[5]) )
# Computing the unnormalized log likelihood
sum(log(mvtnorm::dmvnorm(D, m, s)))
}
# Two chains
ans <- MCMC(
fun,
initial = c(mu0=5, mu1=5, s0=5, s01=0, s2=5),
nchains = 2,
lb      = c(-10, -10, .01, -5, .01),
ub      = 5,
nbatch  = 1e5,
thin    = 20,
scale   = .01,
burnin  = 5e3,
useCpp  = TRUE,
D       = D
)
summary(ans)
plot(ans)
devtools::use_travis()
devtools::use_coverage(type="codecov")
devtools::use_appveyor()
library(amcmc)
library(amcmc)
library(amcmc)
